# C++学习笔记（四）

## 一、内存的分区模型

C++程序在执行过程中，将内存划分为4个区域

- 代码区：存放函数体的二进制代码，由**操作系统**进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由**编译器自动分配释放**，存放函数的参数值，局部变量等等
- 堆区：由**程序员分配和释放**，若程序员不释放，程序结束时由操作系统回收

**内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程**

程序运行前只有代码区和全局区，而只有程序运行之后才会有栈区和堆区

### 1.1程序运行前

在程序编译后，生成了exe可执行程序，为执行该程序前分为了两个区域：

1、代码区：

- 存放CPU执行的机器指令
- 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是**只读**的，使其只读的原因是防止程序意外地修改它的指令

2、全局区

- 全局变量和静态变量存放于此
- 全局区还包括了常量区，字符串常量和其他常量也存放于此
- **该区域的数据在程序结束后由操作系统释放**

使用如下代码可以看到两个区域的范围是不一样的：

```cpp
#include "iostream"
using namespace std;

// 全局变量
int g_a = 10;
int g_b = 10;

int main() {
    // 普通变量
    int a = 10;
    int b = 10;
    cout << "局部变量a的地址为:" << &a << endl;
    cout << "局部变量b的地址为:" << &b << endl;
    // 全局变量
    cout << "全局变量a的地址为:" << &g_a << endl;
    cout << "全局变量b的地址为:" << &g_b << endl;
    return 0;
}
```

结果如下所示，可以发现是存在不同存储模块的

![未命名.png](https://s2.loli.net/2021/12/08/Fw3phTCejVnoO9G.png)

查看静态变量的地址后也可以返现，静态变量static同样的，也是放在一个区域段中的

### 1.2程序运行后

#### 1.2.1栈区

**注意事项：不要返回局部变量的地址**

栈区的数据由编译器管理开辟和释放

#### 1.2.2堆区

堆区是有程序员分配释放，如果程序员不释放，程序结束时会有操作系统回收

在C++中的主要利用new关键字来开辟内存

#### 1.2.3new关键字

C++中利用**new**操作符在堆区开辟数据

堆区开辟的数据，有程序员手动开辟，手动释放，释放利用关键字**delete**

- 语法：`new 数据类型`

利用new创建的数据，会返回该数据对应的类型指针

```cpp
#include "iostream"
using namespace std;

int * func() {
    // 在堆区创建一个整型数据
    // 注意：new返回的是该数据类型的指针
    int * p = new int(10);
    return p;
}

// new的基本语法
void test01() {
    int * p = func();
    cout << *p << endl;
    // 如果想释放堆区的内存，利用关键字delete
    delete p;
    // 内存已经被释放，再次访问就是非法操作
    cout << *p << endl;
}

// 在堆区使用new开辟数组
void test02() {
    int * arr = new int[10]; // 创建一个10个元素的数组
    for (int i = 0; i < 10; i++) {
        arr[i] = i + 100;
    }
    for (int i = 0; i < 10; i++) {
        cout << arr[i] << endl;
    }
    // 释放数组的时候，要加[]才行
    delete[] arr;
}
```

**注意：使用delete释放数组的时候，要加[]才行**

## 二、C++引用

### 2.1基本语法

- 作用：给变量起别名
- 语法：`数据类型 &别名 = 原名`

注意：引用必须要初始化且引用一旦初始化之后就不可以更改

### 2.2引用做函数参数

```cpp
#include "iostream"
using namespace std;

void quote_swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int a = 10;
    int b = 20;
    quote_swap(a, b);
    cout << a << endl;
    cout << b << endl;
    return 0;
}
```

### 2.3引用做函数返回

在引用做为函数的返回时，函数的调用可以做为**左值**

在使用引用作为函数返回时，注意：**不要返回局部变量的引用**

```cpp
#include "iostream"
using namespace std;

int& quote_return() {
    static int a = 10;
    return a;
}

int main() {
    cout << quote_return() << endl;
    quote_return() = 1000;
    cout << quote_return() << endl;
    return 0;
}
```

### 2.4引用的本质

引用的本质就是在C++内部的实现就是一个指针常量

- C++推荐使用引用计数，因为语法非常方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做过了

### 2.5常量引用

常量引用作用就是用来修饰形参，防止误操作

在函数列表中，可以添加const用于修饰形参，防止形参改变实参

## 三、函数高级

### 3.1函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的

语法：`返回值类型 函数名 (参数 = 默认值) {}`

如果自己穿入了数据，就用自己的数据，如果没有就会使用默认值

注意事项：

- **如果某个位置已经有了默认参数，那么这个位置往后，从左向右都必须有默认值**
- 如果函数的声明有了默认参数，那么函数的实现就不能有默认参数

```cpp
int func(int a, int b = 10, int c = 10) {
    return a + b + c;
}

// 声明
int func2(int a = 10, int b = 10);
// 实现
int func2(int a, int b) {
    return a + b;
} 
```

### 3.2函数占位参数

C++中函数的形参列表里可以有占位参数，用来占位，**调用函数时必须填补该占位**

语法：`返回值类型 函数名(数据类型) {}`

### 3.3函数重载

函数重载的作用就是，函数名可以相同，但作用不相同，提高语言的复用性

重载满足条件：

- 同一个作用域下
- 函数名相同
- 函数参数类型不同，或者个数不同，或者顺序不同

**函数的返回值不可以做为函数重载的条件**
